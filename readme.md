## go-middleware

### 中间件仓库包括http和grpc的中间件

####  目前实现http标准库加解密中间件

#### 加密逻辑

1、加密方式采用非对称加密 + 动态密码 + 对称加密

2、RSA算法实现非对称加密，客户端传输时使用公钥加密，服务端用私钥解密，获取AES对称加密密码、AES向量，以及校验用的时间指纹

3、AES算法实现对称加密，密码和向量在每次发请求时动态生成

#### 实现细节

http传输head头自定义一个字段，例如该字段叫X-AuthToken，该字段的的值由以下几个部分组成：[加密版本]:RSA加密([AES动态密码:AES密码向量],公钥)，例如：X-AuthToken: v1:{RSA加密内容}

server端首先解析head头中X-AuthToken，获取到value，然后获取到加密版本号`v1`，使用v1版本的解密手段（v1版本私钥）处理RSA加密内容，最终server端获取到body解密的AES密码和AES向量

之后对request的参数部分进行解密，获取到对应真正的参数，返回response则用第一步获取到的AES密码和向量对response的json串进行加密，客户端用生成的密码和向量进行解密。

#### 为什么要这样做

非对称加密较为耗时，因此只对固定格式的串进行加密，减小性能开销，而传输的body部分则使用对称加密使得性能和保密性都相对比较不错。

客户端随机生成密码和AES向量的处理办法：

随机生成的密码原则上需要唯一性，保证唯一性可以带上时间属性，最简单的例如MD5(时间戳），然后从MD5时间戳中做一个简单的获取密码规则

而AES向量是为了使AES碰撞密码变的更难产生的，所以也可以通过类似的方式或者直接random的方式获取

#### 关于调试和扩展

如果私钥泄密、算法泄密扩展问题，我们可以通过X-AuthToken：v1 同时向下兼容。

#### 使用方式

协议约定
一、公钥和私钥

公钥

-----BEGIN PUBLIC KEY-----
test 
-----END PUBLIC KEY-----
二、请求头

统一约束header请求头：X-AuthToken ，解析header头时，请忽略大小写。

秘钥规则： 版本号:base64(秘钥:向量).

三、版本号约定

三位数字：第一位大版本，第二三位，小版本。

大版本主要是更新加密算法与逻辑

小版本主要更新AES秘钥解析方式。

加密后使用base64进行encode，同理拿到数据之后先base64进行 decode

版本号	约定

v1	使用RSA算法从header头解析AES的秘钥和向量，使用AES的cbc模式进行加解密

四、响应

如果请求头里包含X-AuthToken，服务端会进行加密处理，把响应结果加密返回。

加密后响应头里会添加：Encrypt ，value: 加密版本号。

例如： Encrypt : v1
